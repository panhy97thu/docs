PTAP01 兼容DID的自主身份标识应用接口定义（草案 20191112）

采用PTTP协议访问一个奥丁号（例如 ppk:12345# 或 ppk:joy/12345#等），所获得PTTP应答数据报文将相应支持DID协议相关定义，来支持身份标识相关认证和授权应用。


数据报文中的正文内容(content)是一个JSON编码字符串,包含指定该ODIN标识前缀的拥有者相关身份验证信息，具体定义如下：
    {
        "ver":"说明：ODIN标识协议定义版本，初始为1",
        "title":"说明：可选的标识名称字符串", 
        "authentication": [{
            // used to authenticate as did
            "type": "bitcoin_secp256k1",   //对应bitcoin算法
            "publicKeyHex": "231e...."  //对应公钥（HEX编码)
          },{
            // used to authenticate as did
            "type": "RsaVerificationKey2018", //对应RSA算法
            "publicKeyPem": "-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\r\n"  //对应公钥（BASE64编码)
          }],
    }
    注：上述authentication数组可以提供一个或多个公钥凭证，应用可以依序验证私钥签名直到有匹配记录。

应用的数据库需要在用户表里增加一个字段，用来存关联的奥丁号，取名可以是user_odin_uri, 字符串类型，长度为80个字节或以上，索引设为“不能重复”。    
应用可以在用户属性编辑界面，提供“修改所关联奥丁号”的功能。

一、兼容oAuth的跨域第三方认证流程
    参考传统oAuth验证流程，通过使用第三方提供的ODIN身份验证服务，应用前端代码实现上非常简单。

    应用先选择奥丁号开放认证服务提供者进行登记，如 https://tool2.ppkpub.org/oauth/
    提交”重定向URI”（redirection URI）后，获得后面调用oAuth协议需要的 client_id 和 client_secret
    
    然后用奥丁号登录的实现步骤如下：

（A）用户访问应用，后者将前者导向认证服务提供者的地址,
     例如：https://tool2.ppkpub.org/oauth/authorize.php?response_type=code&client_id=testclient&state=testpass&redirect_uri=https://tool2.ppkpub.org/oauth/client.php
     
（B）用户选择是否给予应用授权。

（C）假设用户给予授权，认证服务器将用户导向应用事先指定的”重定向URI”（redirection URI），同时附上一个授权码(code)。

（D）应用收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌(access_token)。这一步是在应用的后台服务器上完成的，对用户不可见。
     例如：
     将类似如下数组
        [
            "grant_type" : "authorization_code",
            "code" : "上一步获得的授权码(code)",
            "client_id" : "testclient",
            "client_secret" : "testpass",
            "redirect_uri" : "https://tool2.ppkpub.org/oauth/client.php"
        ]
    以表单形式POST到 https://tool2.ppkpub.org/oauth/token.php
     
（E）认证服务器核对了授权码和重定向URI，确认无误后，向应用提供访问令牌（access token）和更新令牌（refresh token）
     应答为json格式，示例如下：
     {
      "access_token":"0bf3ea9f460ebb770e53f2795392d88afd878000",
      "expires_in":3600,
      "token_type":"Bearer",
      "scope":null,
      "refresh_token":"f953d5fd6d4ed0fa83c20afe2fcd5a1b74374ec6"
     } 

（F）应用使用访问令牌（access token）从认证服务器获得对应获得授权的用户资料信息（如奥丁号，昵称和头像图片网址等）
    例如： https://tool2.ppkpub.org/oauth/resource.php?client_id=testclient&state=testpass&access_token=e63f3e4674010429
    应答为json格式，示例如下：
    {
     "success":true, 
     "userInfo":[
        "user_odin_uri" : "ppk:12345#",
        "username" : "tester",
        "avatar" : "http://ppkpub.org/images/user.png"
     ]
    }

参考示例源码： https://github.com/ppkpub/sdk/blob/master/php-oauth/client.php
 
注：建议使用https来提高前后端交互过程的信息安全

二、应用自主认证参考流程
应用可以完全自主实现对奥丁号的登录验证，相比oAuth方案在实现上相对复杂些，但可以获得更完整的自主性。

2.1 登录入口页面(Login page)：
 参考示例源码： https://github.com/ppkpub/OdinSwapTool/blob/master/login.php

 相关实现流程如下：
（A）在前端网页上放置"以奥丁号登录”的按钮

（B）在用户点击后，JS判断当前网页环境是否支持实例化PPk浏览器的PeerWeb插件，
   JS代码示例：  
        if(typeof(PeerWeb) == "undefined"){ 
            console.log("PeerWeb not valid");
            //进入C1流程
        }else{
            console.log("PeerWeb enabled");
            //进入C2流程
        }


（C1）如果不支持对应插件，则以AJAX形式从后端获得一个唯一登录码（与用户当前session关联），扫码验证网址和获取结果网址，
   应答的JSON定义参考如下：
   {
     "code"=> 0, 
     "msg" => "qruuid registered ok",
     "data"=> array(
        "qruuid"=>"生成的唯一登录码",
        "confirm_url"=>"扫码确认网址"
        "poll_url"=>"获取结果网址",  
     )
   }
   注:这里的示例是采用简单的轮训方式，可以改用WebSocket主动通知方式。

   显示二维码供扫码验证, 二维码内容为上述应答里的扫码确认网址(confirm_url)，并提示"等待扫码中”，
   用户另行使用支持ODIN号验证的APP扫码打开访问该网址进行确认操作，应用后端将相应更新的对应登录码的状态为"已通过”。
   
   
   提示"等待扫码中”的页面会通过AJAX访问获取结果网址(poll_url)，定时轮询对应登录码的状态，直到状态为"已通过”，
   则相应切换到用户登录后的网页,相应的网页后端处理对session的登录状态做判断处理即可。

（C2）如果支持对应插件，则读取PPk浏览器的当前缺省用户的ODIN标识,如下所示
        PeerWeb.getDefaultODIN(
            "callback_getDefaultODIN"  //回调方法名称
        );

   对应JS回调方法示例：        
       function callback_getDefaultODIN(status,obj_data){
            if("OK"==status){
                if(obj_data.odin_uri!=null || obj_data.odin_uri.trim().length>0){
                    authAsOdinOwner(obj_data.odin_uri);
                }
            }else{
                alert("请先设置所要使用的奥丁号！");
            }
        }


   在回调方法里取得当前用户ODIN标识后，可进一步调用插件接口来生成签名：
       function authAsOdinOwner(user_odin_uri){
            $.ajax({
                type: "GET",
                url: "login_uuid.php",  //在后端登记获得相应的唯一登录事务号的网址
                data: {},
                success: function (result) {
                    var obj_resp = JSON.parse(result);
                    if (obj_resp.code == 0) {
                        //提取相应的唯一登录事务号
                        var qruuid=obj_resp.data.qruuid;
                        
                        var requester_uri="请求者的网址，可以填写为当前网址";
                        var auth_txt=requester_uri+","+user_odin_uri+","+qruuid;  //需要签名的原文
                        mTempDataHex = stringToHex(auth_txt);
                        
                        //请求用指定资源密钥来生成签名
                        PeerWeb.signWithPPkResourcePrvKey(
                            user_odin_uri,
                            requester_uri ,
                            mTempDataHex,
                            "callback_signWithPPkResourcePrvKey"  //回调方法名称
                        );
                    }else{
                        alert("获取登录事务号失败！\n"+result);
                    }
                }
            });
        }
        
    对应JS回调方法示例：        
        function callback_signWithPPkResourcePrvKey(status,obj_data){
            try{
                if("OK"==status){
                    //提交给后端验证签名以确认登录是否通过
                    var auth_txt_hex = mTempDataHex ; //所签名的原文
                    var user_sign = obj_data.algo+":"+obj_data.sign ; //签名
                    var confirm_url="login_verify.php?user_odin_uri="+encodeURIComponent(user_odin_uri)+"&auth_txt_hex="+auth_txt_hex+"&user_sign="+encodeURIComponent(user_sign);
                    $.ajax({
                        type: "GET",
                        url: confirm_url,
                        data: {},
                        success: function (result) {
                            var obj_resp = JSON.parse(result);
                            if (obj_resp.code == 0) {
                                self.location="登录通过后的网址";
                            }else{
                                alert("用户身份标识签名验证未通过！\n"+result);
                            }
                        }
                    });

                }else{
                    alert("无法签名指定资源！\n请检查确认该资源已配置有效的验证密钥。");
                }
            }catch(e){
                alert("获得的签名信息有误!\n"+e);
            }
        }

   后端验证签名时，需要调用PTTP协议SDK来获取指定用户ODIN标识属性里的公钥，然后验证所得签名是否有效并相应处理。
   
   
   
   
2.2 扫码确认登录页面(Scan qrcode to confirm)
   参考示例源码： https://github.com/ppkpub/OdinSwapTool/blob/master/login_verify.php
   
   相关实现流程如下：
   （A）在用户扫码打开该页面后，点击“确认登录”，JS判断当前网页环境是否支持实例化PPk浏览器的PeerWeb插件，
   JS代码示例：  
        if(typeof(PeerWeb) == "undefined"){ 
            console.log("PeerWeb not valid");
            //进入B1流程
        }else{
            console.log("PeerWeb enabled");
            //进入B2流程
        }


   （B1）如果不支持对应插件，则将网页转向到可用的网页版PPk签名工具并附加上当前网页链接，如
        http://ppk001.sinaapp.com/odin/?login_confirm_url=当前网页链接
        
        由PPk签名工具生成签名后回调当前网页链接，并在URL里传入以下参数进行验证：
        qruuid : 唯一登录事务号
        user_odin_uri : 用户使用的ODIN标识
        auth_txt_hex ：签名对应原文
        user_sign : 生成的签名
        response_type : 验证结果展现方式，可选html或image
        
   
   （B2）如果支持对应插件，则读取PPk浏览器的当前缺省用户的ODIN标识,如下所示
        PeerWeb.getDefaultODIN(
            "callback_getDefaultODIN"  //回调方法名称
        );

   对应JS回调方法示例：        
       function callback_getDefaultODIN(status,obj_data){
            if("OK"==status){
                if(obj_data.odin_uri!=null || obj_data.odin_uri.trim().length>0){
                    authAsOdinOwner(obj_data.odin_uri);
                }
            }else{
                alert("请先设置所要使用的奥丁号！");
            }
        }


   在回调方法里取得当前用户ODIN标识后，可进一步调用插件接口来生成签名：
       function authAsOdinOwner(user_odin_uri){
            var requester_uri = window.location.href;
            var auth_txt=requester_uri+','+user_odin_uri+','+document.getElementById("qruuid").value;  //需要签名的原文

            mTempDataHex = stringToHex(auth_txt);
            document.getElementById("auth_txt_hex").value=mTempDataHex;
            
            //请求用指定资源密钥来生成签名
            PeerWeb.signWithPPkResourcePrvKey(
                user_odin_uri,
                requester_uri ,
                mTempDataHex,
                'callback_signWithPPkResourcePrvKey'  //回调方法名称
            );
        }
        
    对应JS回调方法示例：        
        function callback_signWithPPkResourcePrvKey(status,obj_data){
            if("OK"==status){
                //提交给后端验证签名以确认登录是否通过
                var auth_txt_hex = mTempDataHex ; //所签名的原文
                var user_sign = obj_data.algo+":"+obj_data.sign ; //签名
                var confirm_url="login_verify.php?user_odin_uri="+encodeURIComponent(user_odin_uri)+"&auth_txt_hex="+auth_txt_hex+"&user_sign="+encodeURIComponent(user_sign);
                self.location=confirm_url;
            }else{
                alert("无法签名指定资源！\n请检查确认该资源已配置有效的验证密钥。");
            }

        }

   
   
